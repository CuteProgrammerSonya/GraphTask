# GraphTask
## Профильное задание C++ стажер VK Maps 
### Решение задачи
Для решения данной задачи был написан алгоритм обхода графа BFS (Breadth-first search), работающий за временную сложность O(V + E), где V - количество вершин, а Е - количество рёбер.

Так как граф ненаправленный и вес каждого ребра равен 1, сделан выбор в пользу этого более простого алгоритма по сравнению с алгоритмами Bellmun-Ford и Dijkstra.

Входные данные считываются из файла graph.txt, исходный граф представляется в виде списка смежности.

Алгоритм BFS с поиском кратчайшего пути от текущей вершины до каждой вершины графа:
1. Создаются пустая очередь, в которой будут вершины графа, и массив посещённых вершин.
2. Стартовая вершина добавляется в очередь и отмечается посещённой.
3. Далее выполняется основной цикл, в процессе которого из очереди извлекается самая верхняя вершина. Для неё просматривается список всех соседей.
4. Если соседняя вершина не была посещена, то расстояние до неё выражается как "расстояние до текущей вершины + 1". Ставится отметка о посещении и вершина добавляется в очередь.
5. Если соседняя вершина уже была посещена, то ничего не происходит.
6. Текущая вершина (для которой только что просматривали всех соседей) удаляется.
7. Цикл продолжается до тех пор, пока все вершины не будут посещены и в очереди не останется ни одной.

### Иерархия проекта
Решение создавалось в Visual Studio, оно находится в папке: Graph->Graph.sln

Файл с исходным кодом находится: Graph->Graph->main.cpp

Файл с заданным для примера графом: Graph->Graph->graph.txt

Его название задано в коде при открытии файла.

